<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebSiftGPU - Pyramid Visualization</title>
    <link rel="stylesheet" href="../styles/common.css">
    <link rel="stylesheet" href="../styles/demo.css">
    <style>
        body {
            overflow: auto !important;
        }

        .pyramid-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 2rem;
        }

        .octave-row {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding-bottom: 1rem;
            border-bottom: 1px solid #333;
        }

        .octave-row h3 {
            min-width: 100px;
        }

        .texture-card {
            background: #111;
            padding: 0.5rem;
            border-radius: 4px;
            text-align: center;
        }

        canvas {
            background: #000;
            border: 1px solid #444;
            max-width: 256px;
            height: auto;
        }

        .label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.2rem;
        }
    </style>
</head>

<body>
    <div class="container" style="max-width: 1200px;">
        <h1>SIFT Pyramid Visualization</h1>
        <p>Visualizing Gaussian and Difference of Gaussian (DoG) pyramids for a packed WebGPU SIFT implementation.</p>

        <div class="controls">
            <button id="loadTest" class="btn btn-primary">Process Test Image</button>
            <input type="file" id="fileInput" hidden accept="image/*">
            <button id="uploadBtn" class="btn btn-secondary">Upload Image</button>
        </div>

        <div id="status" class="stats-panel" style="margin-top: 1rem; display: none;">
            <div class="stat-item"><span id="msg" class="value">Ready</span></div>
        </div>

        <div class="pyramid-container" id="viz">
            <!-- Content generated here -->
        </div>
    </div>

    <script type="module">
        import { SIFTWebGPUPacked } from '../src/sift-webgpu-packed.js';

        const sift = new SIFTWebGPUPacked({ numOctaves: 4, scalesPerOctave: 3 });
        await sift.init();

        const viz = document.getElementById('viz');
        const status = document.getElementById('status');
        const msg = document.getElementById('msg');

        document.getElementById('uploadBtn').onclick = () => document.getElementById('fileInput').click();
        document.getElementById('fileInput').onchange = (e) => process(URL.createObjectURL(e.target.files[0]));
        document.getElementById('loadTest').onclick = () => process('https://picsum.photos/800/600');

        async function process(url) {
            status.style.display = 'grid';
            msg.textContent = 'Processing SIFT...';
            viz.innerHTML = '';

            await sift.detectKeypoints(url);
            msg.textContent = 'SIFT Complete. Extracting Pyramids...';

            const cache = sift.pyramidCache;
            if (!cache) return;

            // 1. Visualize Gaussian Pyramid
            renderPyramid(cache.gaussianPyramid, "Gaussian Pyramid", true);

            // 2. Visualize DoG Pyramid
            renderPyramid(cache.dogPyramid, "DoG Pyramid (Contrast Enhanced)", false);

            msg.textContent = `Visualization Ready (${sift.keypoints.length} features detected)`;
        }

        async function renderPyramid(pyramid, title, isGaussian) {
            const section = document.createElement('div');
            section.innerHTML = `<h2>${title}</h2>`;
            viz.appendChild(section);

            for (let o = 0; o < pyramid.length; o++) {
                const row = document.createElement('div');
                row.className = 'octave-row';
                row.innerHTML = `<h3>Octave ${o}</h3>`;

                const octave = pyramid[o];
                for (let s = 0; s < octave.length; s++) {
                    const tex = octave[s];
                    const data = await sift.readbackTexture(tex);

                    const card = document.createElement('div');
                    card.className = 'texture-card';
                    const canvas = document.createElement('canvas');

                    // SIFT packed textures are (W/2, H/2) but contain 4 original pixels
                    const pw = tex.width;
                    const ph = tex.height;
                    const ow = pw * 2;
                    const oh = ph * 2;

                    canvas.width = ow;
                    canvas.height = oh;

                    drawPackedData(canvas, data, pw, ph, isGaussian);

                    card.appendChild(canvas);
                    const label = document.createElement('div');
                    label.className = 'label';
                    label.textContent = `Scale ${s} (${ow}x${oh})`;
                    card.appendChild(label);
                    row.appendChild(card);
                }
                section.appendChild(row);
            }
        }

        function drawPackedData(canvas, data, pw, ph, isGaussian) {
            const ctx = canvas.getContext('2d');
            const ow = pw * 2;
            const oh = ph * 2;
            const idata = ctx.createImageData(ow, oh);
            const pixels = idata.data;

            // Data is Float32Array [r, g, b, a, ...] of length pw*ph*4
            for (let y = 0; y < ph; y++) {
                for (let x = 0; x < pw; x++) {
                    const idx = (y * pw + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];

                    // De-pack into 2x2 block
                    // Gaussian values are [0, 1]. DoG values are tiny [-0.1, 0.1].
                    const scale = isGaussian ? 255 : 2550; // Boost DoG for visibility
                    const offset = isGaussian ? 0 : 128; // Center DoG

                    const setPix = (lx, ly, val) => {
                        const pi = ((y * 2 + ly) * ow + (x * 2 + lx)) * 4;
                        const v = Math.min(255, Math.max(0, val * scale + offset));
                        pixels[pi] = pixels[pi + 1] = pixels[pi + 2] = v;
                        pixels[pi + 3] = 255;
                    };

                    setPix(0, 0, r);
                    setPix(1, 0, g);
                    setPix(0, 1, b);
                    setPix(1, 1, a);
                }
            }
            ctx.putImageData(idata, 0, 0);
        }
    </script>
</body>

</html>